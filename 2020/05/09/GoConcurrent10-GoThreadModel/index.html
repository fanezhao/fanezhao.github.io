<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="本博客于 2020 年建站，记录了我在工作过程中学到的技术、运营及产品等知识，并以原创文章的形式分享给大家。未来仍然将坚持不懈的分享技术知识、工作经历等原创内容。 希望看到本博客的前辈多指点扶正、同行们能一起共同学习与进步、正在学习的小伙伴能通过本博客学到对自己有用的知识。">
  <meta name="keyword" content="ZMOYI, 原创博客, Java, Golang, Linux, 全栈, 后端开发, 前端开发">
  
    <link rel="shortcut icon" type="image/ico" href="http://cdn.zmoyi.com/static/images/ico.png"/>
  
  <title>
    
      Go并发编程（十）Go并发编程模型 | Fane&#39;Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  
    
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
  
    
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 4.2.0"></head>
<div class="wechat-share">
  <img src="http://cdn.zmoyi.com/static/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Fane'Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Go并发编程（十）Go并发编程模型</h2>
  <p class="post-date">2020-05-09</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><blockquote>
<p>前面我们学习了很多的有关并发编程的基础知识和概念，今天我们来看一下Go语言的并发编程模型。Go的并发编程模型非常有特点，它的运作机制也非常值得我们研究，下面我们就来学习一下。</p>
</blockquote>
<h2 id="原理探究"><a href="#原理探究" class="headerlink" title="原理探究"></a>原理探究</h2><p>在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。<code>goroutine</code>这个特有名词是Go独创的，它代表着可以并发执行的Go代码片段。那么<code>goroutine</code>的真正含义是什么呢？Go语言打出的标语是这样的：</p>
<blockquote>
<p>不要用共享内存的方式来通信，而应该以通信的方式共享内存。</p>
</blockquote>
<p>更确切的讲，把数据放在共享内存中供多个线程访问，这一方式虽然在基本思想上非常简单，却使并发访问控制变得异常复杂。只有做好各种约束和控制才能正确实施。但是，正确性往往不是我们唯一想要的，软件系统的可伸缩性指标也是高优先级的指标。可伸缩性越好，就越能获得计算机硬件（比如多CPU）的红利。然而一些同步方法的使用，让这种红利的获得变得困难的许多。</p>
<p>Go不推荐用共享内存的方式传递数据，而推荐使用<strong><code>channel</code>(或称“通道”)</strong>。<code>channel</code>主要用来在多个<code>goroutine</code>之间传递数据，并且会保证整个过程的并发安全。不过，Go依然提供了一些传统方法（比如互斥量、条件变量等）。</p>
<h2 id="线程实现模型"><a href="#线程实现模型" class="headerlink" title="线程实现模型"></a>线程实现模型</h2><p>Go的线程实现模型与两级线程实现模型有点类似（<a href="http://zmoyi.com/2020/04/27/GoConcurrent8-ThreadBase/">什么是两级线程实现模型？</a>），Go的线程实现模型有3个核心元素：</p>
<ul>
<li><strong>M</strong>：<code>machine</code>的缩写。一个M代表一个内核线程，或称“工作线程”。</li>
<li><strong>P</strong>：<code>processor</code>的缩写。一个P代表执行一个Go代码片段所必须的资源（或称“上下文环境”）。</li>
<li><strong>G</strong>：<code>goroutine</code>的缩写。一个G代表一个Go代码片段。前者是对后者的一种封装。</li>
</ul>
<p>简单来说，一个G的执行需要P和M的支持。一个M和一个P关联之后，就行成了一个有效的G运行环境（内核线程+上下文）。每个P都会包含一个<u><strong>可运行的G的队列（runq）</strong></u>。该队列中的G会被依次传递给与本地P关联的M，并获得运行时机。</p>
<blockquote>
<p>这里约定一下：把运行当前G的那个M称为“当前M”，并把与当前M关联的那个P称作”本地P”。</p>
</blockquote>
<p>从宏观上看，M、P和G之间的联系如下图所示，但是它们的实际关系要比为复杂的多。</p>
<img src="http://cdn.zmoyi.com/static/images/Go线程实现模型三个核心元素.jpg">

<p>下面我们看看它们与内核调度实体（KSE）的之间的关系是怎样的。</p>
<img src="http://cdn.zmoyi.com/static/images/M、P和G与KSE之间的关系.jpg">

<p>可以看到，M与<code>KSE</code>之间总是一对一的关系，一个M能且仅能代表一个内核线程。Go的<strong>运行时系统（runtime system）</strong>用M代表一个内核调度实体。M与<code>KSE</code>之间的关联非常稳固，一个M在其生命周期内只会与一个<code>KSE</code>产生关联。相比之下，M与P、P与G之间的关联都是易变的，它们的关系会在实际调度过程中改变。</p>
<p>其中，M与P的关系也总是一对一的，而P与G之间则是一对多的关系（还记得前面说的P的可运行G的队列么？）。此外，M与G也会建立关联，因为一个G终归会由一个M来负责运行；它们之间的关联会由P来牵线。注意，由于上述三者之间的关系在实际调度中多变，上图仅能作为一般概括。</p>
<p>上面，我们已经大致了解了这些核心元素之间的关系，Go的运行时系统会对这些实体的实例进行实时管理和调度，下面我们来看下这些实体内部的值得关注的细节。</p>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>一个M代表一个内核线程。在大多数情况下，创建一个M，都是由于没有足够的M来关联P并运行其中可运行的G。除此之外，在运行时系统执行系统监控或垃圾回收等任务的时候，也会导致新的M的创建。M的部分结构如下图所示：</p>
<img src="http://cdn.zmoyi.com/static/images/M的部分结构.jpg">

<p>M结构中的字段众多，这里只挑选了几个初步认识M最重要的几个字段（M的完整结构在标准库代码包runtime包中的runtime2.go文件中）。其中：</p>
<ul>
<li><p><strong>g0</strong>：字段g0表示一个特殊的<code>goroutine</code>。这个<code>goroutine</code>是Go运行时系统在启动之初创建的，用于执行一些运行时任务。</p>
</li>
<li><p><strong>mstartfn</strong>：字段mstartfn代表的是用于在新M上启动某个特殊任务的函数。这些任务可能是系统监控、GC辅助或M自旋等。</p>
</li>
<li><p><strong>curg</strong>：字段curg会存放当前M正在运行的G的指针。</p>
</li>
<li><p><strong>p</strong>：字段p的值会指向与当前M相关联的那个P。mstartfn、curg和p最能体现当前M的即时情况。</p>
</li>
<li><p><strong>nextp</strong>：字段nextp用于暂存与当前M有潜在关联的P。<strong>把调度器将某个P赋给某个M的nextp字段的操作，称为M和P的预联</strong>。运行时系统有时会把刚刚重新启用的M和已与它预联的那个P关联在一起，这也是nextp字段的主要作用。</p>
</li>
<li><p><strong>spinning</strong>：字段spining是bool类型的，它用于表示这个M是否正在寻找可运行的G。在寻找过程中，M会处于自旋状态，这也是该字段名的由来。</p>
</li>
<li><p><strong>lockedg</strong>：字段lockedg表示的就是与当前M锁定的那个G（如果有的话）。Go运行时系统可以把一个M和一个G锁定在一起。一旦锁定，这个M就只能运行这个G，这个G也只能由这个M运行。标准库代码包<code>runtime</code>中的函数<code>LockOSThread</code>和<code>UnlockOSThread</code>为我们提供了锁定和解锁的具体方法。</p>
</li>
</ul>
<p>M在创建之初，会被加入到<u><strong>全局的M列表（runtime.allm）</strong></u>中。这时，它预联的P会被设置，如果运行时系统要用此M执行系统监控或垃圾回收等任务，会把起始函数也一并设置了。最后，运行时系统会为这个M专门创建一个新的内核线程并与之相关联。如此一来，这个M就为执行G做好了准备。这里的全局列表并没有什么特殊的意义，运行时系统在需要的时候，会通过它获取到所有的M的信息。同时，它也可以防止M被当作垃圾回收掉。</p>
<p>在新M被创建之后，Go运行时系统会对它进行一番初始化，其中包括对自身所持的栈空间以及信号处理方法的初始化。初始化完成后，如果该M的起始函数存在，它将会被执行。注意，如果这个起始函数代表的是系统监控任务的话，那么该M会一直执行它，而不会继续后面的流程。否则，在起始函数执行完毕之后，当前M将会与那个预的P完成关联，并准备执行其它的任务。</p>
<p>运行时系统管辖的M（或者说<code>runtime.allm</code>中的M）有时也会被停止，比如在运行时系统执行垃圾回收任务的过程中。运行时系统在停止M的时候，会把它放入<u><strong>调度器的空闲M列表（runtime.sched.midle）</strong></u>。这很重要，因为在需要一个未被使用的的M时，运行时系统会先尝试从该列表中获取。M是否空闲，仅以它是否存在于调度器的空闲M列表为依据。</p>
<p>单个Go程序所使用的M的最大数量是可以设置的。Go程序运行的时候会先启动一个引导程序为其运行建立必要的环境。在初始化调度器的时候，它会对M的最大数量进行初始设置，<strong>初始值为<code>10000</code></strong>。这就意味着，理想情况下，最多可以有10000个内核线程服务于当前的Go程序。由于操作系统内核对进程的虚拟内存的布局控制以及限制大小，如此量级的线程可能很难共存。</p>
<p>我们也可以在Go程序中对其设置，通过调用标准库代码包<code>runtime/debug</code>中的<code>SetMaxThreads</code>函数设置M的最大数量。该函数在调用成功之后，会把旧的M的最大数量作为返回值返回。如果设置的新值比当前M的实际数量小的话会引发运行时<code>panic</code>，所以要非常谨慎的使用这个函数。如果真的要设置的话，越早设置越好。</p>
<h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>P是G能够在M中运行的关键。Go的运行时系统会适时的让P与不同的M建立或断开关联，以使P中的那些可运行的G能够及时获得运行时机，这与操作系统内核在CPU之上实时切换不同的进程或线程情形类似。</p>
<p>改变单个Go程序间接拥有的P的最大数量有两种方法。</p>
<ul>
<li><p>调用函数<code>runtime.GOMAXPROCS</code>传入想要设定的数量。</p>
</li>
<li><p>在Go程序运行前设置环境变量<code>GOMAXPROCS</code>的值。</p>
</li>
</ul>
<p>P的最大数量实际上是对程序中并发运行的G的规模的一种限制。P的数量即为可运行G的队列的数量。一个G在启用后，会先被追加到某个P的可运行队列中，以等待运行时机。一个P只有与一个M关联在一起，才会使其可运行G队列中的G有机会运行。</p>
<p>设置P的最大数量对G和M的数量没有任何影响。当M因系统调用而阻塞（或者说它运行的G进入了系统调用）的时候，运行时系统会把M和与之关联的P分开来。这时，这个P的可运行G队列中还有未被运行的G，那么运行时系统会找一个空闲的M，或创建一个新的M，并与该P关联以满足这个G的运行需要。因此，M的数量在很多时候都比P多，而G的数量一般取决于Go程序本身。</p>
<p>与设置M的最大数量一样，在Go程序启动的时候，引导程序会在初始化调度器时，对P的最大数量进行设置。<strong>这里的默认值会与当前CPU的总核心数据相同</strong>。如果环境<code>GOMAXPROCS</code>的值大于0且不大于硬性上限值256（如果大于256，就会设置成256），引导程序就会为我们设置P的最大数量值。硬性上限值是256原因是Go目前还不能保证在数量比256更多的P同时存在的情况下Go程序仍然保持高效。不过未来可能会改变。</p>
<p>注意，虽然Go并未对何时调用<code>runtime.GOMAXPROCS</code>函数作限制，但是该函数的调用会暂时让所有的P都脱离运行状态，并试图阻止任何用户级别的G的运行（<strong>STW</strong>）。只有在新的P的最大数量设置完成之后，运行时系统才陆续恢复它们。这对程序的性能是非常大的损耗。所以最好在Go的main函数的最前面调用它。当然不改变P的最大数量值是最好了，实际上大多数情况下也不用改变。</p>
<p>在确定P的最大数量之后，运行时系统会根据这个值重整<u><strong>全局的P列表（runtime.allp）</strong></u>。与全局M列表相似，该列表中包含了当前运行时系统所创建的所有P。运行时系统会把这些P中的可运行的G全部取出，放入<u><strong>调度器的可运行G队列</strong></u>中。这是调整全局P列表的一个重要前提。被转移的G，会在以后经由调度再次放入某个P的可运行G队列中。</p>
<p>与空闲M列表类似，运行时系统中也存在一个<u><strong>调度器的空闲P列表（runtime.sched.pidle）</strong></u>。当一个P不再与任何M相关联的时候，运行时系统会把它放入该列表；而当需要一个空闲P关联某个M的时候，会从此列表中取出一个。<strong>注意，P进入空闲列表的一个前提条件是它的可运行G队列必须为空</strong>。例如，在重整全局P列表的时候，P在被清空可运行G队列之后，才会被放入空闲P列表。</p>
<p>与M不同，P本身是有状态的，可能具有的状态如下：</p>
<ul>
<li><p><strong>Pidle</strong>：此状态表明当前P未与任何M存在关联。</p>
</li>
<li><p><strong>Prunning</strong>：此状态表明当前P正在与某个M关联。</p>
</li>
<li><p><strong>Psyscall</strong>：此状态表明当前P中运行的那个G正在进行系统调用。</p>
</li>
<li><p><strong>Pgcstop</strong>：此状态表明运行时系统需要停止调度。例如，运行时系统在开始垃圾回收的某些步骤之前，就会试图把全局P列表中的所有P都置于此状态。</p>
</li>
<li><p><strong>Pdead</strong>：此状态表明当前P已经不会再被使用。如果Go程序在运行中，通过调用<code>runtime.GOMAXPROCS</code>函数减少了P的最大数量，那么多余的P就会被置为此状态。</p>
</li>
</ul>
<p>P在创建之初的状态是<code>Pgcstop</code>，但是这并不意味着运行时系统要进行垃圾回收。其实，P处于这一状态的时间会非常短暂，在紧接着初始化完成之后，运行时系统会将其状态设置为<code>Pidle</code>并放入调度器的空闲P列表。P的状态转换如下图所示：</p>
<img src="http://cdn.zmoyi.com/static/images/P的状态转换.jpg">

<p>可以看到，非<code>Pdead</code>状态的P都会在运行时系统欲停止调度时被置为<code>Pgcstop</code>状态。不过，等到需要重启调度的时候（比如垃圾回收结束后），它们并不会被恢复到原有状态，而会统一置为<code>Pidle</code>状态，再次公平的接受调度。</p>
<p>另一方面，非<code>Pgcstop</code>状态的P都可能因全局P列表的缩小而被认为是多余的，并置为<code>Pdead</code>状态。不过在为<code>Pdead</code>之前，其可运行G队列中的G都会被转移到调度器的可运行队列中，而它的<u><strong>自由G列表中（runtime.p.gFree）</strong></u>也都会被转移到<u><strong>调度器的自由G列表</strong></u>中。</p>
<p>如上所述，每个P中除了一个可运行的G队列外，还有一个自由G列表，这个列表中包含了一些已经运行完成的G。随着运行完成的G的增多，该列表会随之增长，当它增长到一定长度后，运行时系统就会把其中的部分G转移到调度器的自由G列表中。</p>
<p><strong>当使用Go语句欲启用一个G时，运行时系统会先试图从相应P的自由G列表中获取一个现成的G，来封装这个Go语句携带的函数（也称Go函数）。考虑到由于相应P的自由G列表为空而获取不到G的情况，运行时系统会发现在其中G太少时，预先尝试从调度器的自由G列表中转移过来一些G。仅当调度器的自由G列表也为空时，才可能创建一个新的G，这在很大程度上提高了G的复用率。</strong></p>
<p>在P的结构中，可运行的G队列和自由G列表是最重要的两个成员，它们间接的体现了运行时系统对G的调度情况。</p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>一个G就代表一个<code>goroutine</code>（或称<strong>Go例程</strong>），也与go函数相对应。我们只是使用go语句向Go的运行时系统提交了一个并发任务，而Go的运行时系统则会按照我们的要求并发的执行它。<strong>Go的编译器会把go语句变成对内部函数<code>newproc</code>的调用，并把go函数及其参数都作为参数传递给这个函数。</strong>其实go语句并不神秘，它只是一种递送并发任务的方法而已。</p>
<p>运行时系统在接到这样一个调用后，会先检查go函数及其参数的合法性，然后试图从本地P的自由G列表中和调度器的自由G列表中获取可用的G，如果没有获取到，就会新建一个G。</p>
<p>与M和P相同，运行时系统也持有一个<u><strong>G的全局列表(runtime.allgs)</strong></u>，新建的G会第一时间加入该列表，这个全局列表的主要作用是：<strong>集中存放当前运行时系统中的所有G指针</strong>。</p>
<p>无论用于封装当个这个go函数的G是否是新的，运行时系统都会对它进行一次初始化，包括关联go函数以及设置该G的状态和ID等步骤。在初始化完成后，这个G会立即被存储到本地P的<code>runnext</code>字段中，以求更早的运行它；如果这里<code>runnext</code>字段已存有一个G，那么这个已有的G会被“踢到”该P的可运行G队列的末尾，如果这个队列已满，则其会被追加到调度器的可运行G队列中了。</p>
<p>每一个G都会由运行时系统根据其实际情况设置不同的状态，其状态主要如下：</p>
<ul>
<li><strong>Gidle</strong>：表示当前G刚被新分配，但还未初始化。</li>
<li><strong>Grunnable</strong>：表示当前G正在可运行队列中等待运行。</li>
<li><strong>Grunning</strong>：表示当前G正在运行。</li>
<li><strong>Gsyscall</strong>：表示当前G正在执行某个系统调用。</li>
<li><strong>Gwaiting</strong>：表示当前G正在阻塞。</li>
<li><strong>Gdead</strong>：表示当前G正在闲置。</li>
<li><strong>Gcopystack</strong>：表示当前G的栈正在被移动，移动的原因可能是栈的扩展或收缩。</li>
</ul>
<p>除了上述状态，还有一个称为<code>Gscan</code>的状态。不过这个状态不能独立存在，而是组合状态的一部分。比如，<code>Gscan</code>与<code>Grunnable</code>组合成<code>Gscanrunnable</code>状态，代表当前G正在等待运行，同时它的栈正在被扫描，扫描的原因一般是GC任务的执行。</p>
<p>前面讲过，在运行时系统想要用一个G封装go函数时，会先对这个G进行初始化。一旦该G准备就绪，就状态就会被设置为<code>Grunnable</code>。也就是说，一个G真正开始被使用是在其状态设置成<code>Grunnable</code>之后。下图展示了G在其生命周期内的状态流转情况。</p>
<img src="http://cdn.zmoyi.com/static/images/G状态转换.jpg">

<p>一个G在运行过程当中，是否会等待某个事件以及会等待什么样的事件，完全由其封装的go函数决定。例如，如果这个函数中包含对通道值的操作（可能是等待获取值也可能是等待发送值），那么在执行到对应的代码时，这个G就有可能进入<code>Gwaiting</code>状态。又例如，涉及网络I/O的时候也会导致相应的G进入<code>Gwaiting</code>状态。等到事件到来之后，G会被“唤醒”并转换到<code>Grunnable</code>状态，再次等待被运行。</p>
<p>G在退出系统调用的时，运行时系统会先尝试直接运行这个G，仅当无法运行的时候，才会把状态转为<code>Grunnable</code>并放入调度器的自由G列表中，等待再次运行。</p>
<p>最后值得一提的是，进入死亡状态<code>Gdead</code>的G是可以重新初始化并使用的。对比之下，P在进入死亡状态<code>Pdead</code>之后，就只能面临销毁了。处于<code>Gdead</code>状态的G会被放入本地P或调度器的自由G列表，这是它们被重用的前提条件。</p>
<h3 id="核心元素的容器"><a href="#核心元素的容器" class="headerlink" title="核心元素的容器"></a>核心元素的容器</h3><p>上面讲述了Go线程实现模型的3个核心元素——M、P和G，其中多次提到承载它们的容器，现归纳如下：</p>
<table>
<thead>
<tr>
<th>中文名称</th>
<th>源码中的名称</th>
<th>作用域</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>全局M列表</td>
<td>runtime.allm</td>
<td>运行时系统</td>
<td>存放所有M的一个单向链表</td>
</tr>
<tr>
<td>全局P列表</td>
<td>runtime.allp</td>
<td>运行时系统</td>
<td>存放所有P的一个数组</td>
</tr>
<tr>
<td>全局G列表</td>
<td>runtime.allgs</td>
<td>运行时系统</td>
<td>存放所有G的一个切片</td>
</tr>
<tr>
<td>调度器的空闲M列表</td>
<td>runtime.sched.midle</td>
<td>调度器</td>
<td>存放空闲M的一个单向链表</td>
</tr>
<tr>
<td>调度器的空闲P列表</td>
<td>runtime.sched.pidle</td>
<td>调度器</td>
<td>存放空闲P的一个单向链表</td>
</tr>
<tr>
<td>调度器的可运行G队列</td>
<td>runtime.sched.runq.head<br />runtime.sched.runq.tail</td>
<td>调度器</td>
<td>存放可运行G的一个队列</td>
</tr>
<tr>
<td>调度器自由G列表</td>
<td>runtime.sched.gFree.stack<br />runtime.sched.gFree.noStack</td>
<td>调度器</td>
<td>存放自由G的两个单向链表</td>
</tr>
<tr>
<td>P的可运行G队列</td>
<td>runtime.p.runq</td>
<td>本地P</td>
<td>存放当前P的可运行G的一个队列</td>
</tr>
<tr>
<td>P的自由G列表</td>
<td>runtime.p.gFree</td>
<td>本地P</td>
<td>存放当前P的自由G的一个单向链表</td>
</tr>
</tbody></table>
<p>3个全局容器存在的主要目的是为了罗列某个核心元素的全部。这里值得我们注意的是后面4个非全局G的容器。任何G都会存在于全局G列表中，而后面4个存放G的容器则只会存放当前作用域内的、具有某个状态的G。注意，这里的两个可运行G队列中的G拥有几乎平等的运行机会，我们无需关心哪些可运行的G会进入哪个队列。</p>
<p>顺便提一下，从<code>Gsyscall</code>状态转出的G都会被放入调度器的可运行队列，而刚被运行时系统初始化的G都会被放入本地P的可运行G队列。至于从<code>Gwaiting</code>状态转出的G，有的会被放入本地P的可运行队列，有的会被放入调度器的可运行G队列，还有的会被直接运行（刚进行完网络I/O的G就是这样）。此外，这两个可运行G队列之间也会相互转移G。例如，调用<code>runtime.GOMAXPROCS</code>函数，会导致运行时系统把将死的P的可运行G队列中的G，全部转移到调度器的可运行G队列。这也是为了重新分配它们。再如，如果本地P的可运行G队列已满，其中一半的G都会被转移到调度器的可运行G队列中。</p>
<p>调度器的可运行G队列由两个变量代表。<code>head</code>代表变量的头部，<code>tail</code>代表变量的尾部。一般情况下，新的可运行的G会被追加到队列的尾部，并且会从头部取走G，这也体现了队列的<code>FIFO</code>（先进先出）特性。不过，新的可运行的G有时也会被插入头部，刚刚说的调用<code>runtime.GOMAXPROCS</code>函数就是。</p>
<p>另一方面在G转入<code>Gdead</code>状态之后，首先会被放入本地P的自由G列表，而在运行时系统需要用自由的G封装go函数的时候，也会尝试从本地P的自由G列表中获取。如果本地P的自由G列表空了，那么运行时系统就会先从调度器的自由G列表中转移一部分到本地P的自由G列表中。而当本地P的自由G列表已满，运行时系统也会转移一部分到调度器的自由G列表中。</p>
<p>注意，调度器的自由G列表有两个。它们的区别是其中存放的自由G是有栈的还是无栈的。把G放入自由G列表之前，运行时系统会检查该G的栈空间是否为初始大小。如果不是，就释放它让该G变成无栈的，这主要是为了节省资源。另外，在从自由G列表中取出G后，运行时系统会检查它是否拥有栈，如果没有就初始化一个新的栈给它。所有的自由G列表都是<code>FILO</code>（先进后出）的。</p>
<p>与M和P相关的非全局容器分别是调度器的空闲M列表和调度器的空闲P列表，这两个列表都用于存放暂时不被使用的元素。当运行时系统需要时，会从中取出元素的实例并启用。它们俩也是<code>FILO</code>的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章，我们主要学习了Go的并发编程模型以及支撑起Go并发编程模型的主要元素M、P和G，另外还详细介绍它们的有关实现细节，以及承载它们的各种容器，最后还简要介绍了这些容器的作用。通过这些内容，可以使我们对Go的并发编程有一个初步的认识和了解。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Go" >
    <span class="tag-code">Go</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2020/05/01/GoConcurrent9-SyncSecond/">
        <span class="nav-arrow">← </span>
        
          Go并发编程（九）再看同步问题
        
      </a>
    
    
      <a class="nav-right" href="/2020/05/18/GoConcurrent11-Schedt/">
        
          Go并发编程（十一）调度器
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitalk START -->
      <div id="gitalk-container"></div>
      <!-- Gitalk END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">目录</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#原理探究"><span class="toc-nav-text">原理探究</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#线程实现模型"><span class="toc-nav-text">线程实现模型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#M"><span class="toc-nav-text">M</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#P"><span class="toc-nav-text">P</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#G"><span class="toc-nav-text">G</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#核心元素的容器"><span class="toc-nav-text">核心元素的容器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#总结"><span class="toc-nav-text">总结</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://zmoyi.com/2020/05/09/GoConcurrent10-GoThreadModel/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>





  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: '595f268d984e0123456f',
      clientSecret: 'e4c1799bc7a82448653f758927992c6217beb7cb',
      id: window.location.pathname,
      repo: 'fanezhao.github.io',
      owner: 'fanezhao',
      admin: 'fanezhao'
    })
    gitalk.render('gitalk-container')
  </script>




    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy;2020 <a href="https://github.com/fanezhao" target="_blank" rel="noopener">Fane</a>
    | PV: <span id="busuanzi_value_site_pv"></span>
    | UV: <span id="busuanzi_value_site_uv"></span>
    | PPV: <span id="busuanzi_value_page_pv"></span>
    <br>
  </p>
  <div style="width:350px;margin:0 auto; padding:0px 0; overflow: hidden;">
    <a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener" style="display:inline-block;text-decoration: none; height:20px;line-height:20px;float: left;">
        <p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">浙ICP备20012854号</p >
    </a >
    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33011002014629" target="_blank" rel="noopener" style="display:inline-block; text-decoration: none; height:20px; line-height:20px; float:right;">
        <img src="http://cdn.zmoyi.com/static/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" style="float:left;" alt="">
        <p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">浙公网安备 33011002014629号</p >
    </a >
  </div>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script>
    var _baId = '1da5032819b12da8d4c1fb82c6f21ffa';
    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>

<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/script.js"></script>

  </body>
</html>